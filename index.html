<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="user-scalable=no" />
  <link rel="stylesheet" href="./css/reset.css" media="screen" />
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700" rel="stylesheet">
  <link rel="stylesheet" href="./css/style.css" media="screen" />
  <title >Calculator:</title>
</head>
<body onresize="drawPage()">
  <div id="container">
    <div id="displayB">
      <span id="displayBtext">39_characters__________________________</span>
    </div>
    <div id="displayA">
      <span id="displayAtext">waiting for input&nbsp;</span>
    </div>
    <div id="keyboard">
    </div>
  </div>

<script>
// Calculator - by Simon Tharby, 2018 (solution to; https://www.theodinproject.com/courses/web-development-101/lessons/calculator)
// Mobile focussed design that is also appropriately responsive to desktop environment.
// Disambiguation: In this code, 'key' refers / relates to a / the key(s) on the rendered calculator

// --------------------- layout and basic styling -----------------------------

function setKeysTemplate() {
  // '^' = exponentiation, 'C' = clear, '<' = backspace,
  // 'S' = settings, 'F' = fullscreen (landscapeLong && mobile, only)
  let template = [];

  if (layout === "portrait") {
    if (hand === "r") {
      template = ['±', 'S', '<', 'C',
                  '(', ')', '^', '/',
                  '7', '8', '9', '*',
                  '4', '5', '6', '-',
                  '1', '2', '3', '+',
                  '.', '0', '='];
    } else {
      template = ['C', '<', 'S', '±',
                  '/', '^', '(', ')',
                  '*', '7', '8', '9',
                  '-', '4', '5', '6',
                  '+', '1', '2', '3',
                  '=', '0', '.'];
    }
  } else if (layout === "landscape") {
    if (hand === "r") {
      template = ['7', '8', '9', '/', '^', 'C',
                  '4', '5', '6', '*', '(', '<',
                  '1', '2', '3', '-', ')', 'S',
                  '±', '0', '.', '+', '='];
    } else {
      template = ['C', '^', '/', '7', '8', '9',
                  '<', '(', '*', '4', '5', '6',
                  'S', ')', '-', '1', '2', '3',
                  '=', '+', '.', '0', '±'];
    }
  } else if (layout === "landscapeLong" && mobile === false) {
    if (hand === "r") {
      template = ['±', '7', '8', '9', '^', 'S', '<', 'C',
                  '.', '4', '5', '6', '+', '*', '(', ')',
                  '0', '1', '2', '3', '-', '/', '='];
    } else {
      template = ['C', '<', 'S', '^', '±', '7', '8', '9',
                  '(', ')', '*', '+', '.', '4', '5', '6',
                  '=', '/', '-', '0', '1', '2', '3'];
    }
  } else { // landscapeLong && mobile: true
    if (hand === "r") {
      template = ['±', '7', '8', '9', 'F', 'S', '<', 'C',
                  '.', '4', '5', '6', '+', '*', '(', ')',
                  '0', '1', '2', '3', '-', '/', '^', '='];
    } else {
      template = ['C', '<', 'F', 'S', '±', '7', '8', '9',
                  '(', ')', '*', '+', '.', '4', '5', '6',
                  '=', '^', '/', '-', '0', '1', '2', '3'];
    }
  }

  return template;
}

function getDisplayData() {
  calcW = window.innerWidth;
  WinOutW = window.outerWidth;
  screenW = screen.width;
  calcH = window.innerHeight;
  WinOutH = window.outerHeight;
  screenH = screen.height;

  if (screen.width < window.innerWidth) {
    mobile = true; // probably mobile, but not certain
  } else {mobile = false;}
}

function setLayout() {
  if (mobile === false && screenW < 2200) {
    if (calcW > 480) { calcW = 480; }
    if (calcH > 385) { calcH = 385; }
  }

  winRatio = calcW / calcH;

  if (winRatio < 1.2) {
    layout = "portrait";
    displayBheight = calcH * (1 / 15);
    displayAheight = calcH * (2 / 15);
    keyRows = 6;
  } else if (winRatio >= 1.2 && winRatio < 2.1) {
    layout = "landscape";
    displayBheight = calcH * (1 / 11);
    displayAheight = calcH * (2 / 11);
    keyRows = 4;
  } else {
    layout = "landscapeLong";
    displayBheight = calcH * (1 / 9);
    displayAheight = calcH * (2 / 9);
    keyRows = 3;
  }

  keyboardHeight = calcH - displayAheight - displayBheight;

  if (layout === "landscapeLong" && mobile === true) {
    numOfKeys = 24;
  } else {
    numOfKeys = 23;
  }
  keyHeight = (keyboardHeight / keyRows); // -2px for key 1px border (this could change, depending on Theme)
}

function drawPage() {
  getDisplayData();
  setLayout();
  destroyKeys();
  container.style.width = `${calcW}px`

  if (mobile === false) {
    container.style.margin = `${(window.innerHeight - calcH) / 2}px auto`;
  } else {
    container.style.margin = `auto`;
  }

  updateDispB();
  createKeys();
  stylePage();
  addEventListeners();
}

function createKeys() {
  for (let i = 0; i < numOfKeys; i++) {
    const key = document.createElement('div');
    key.classList.add('key');
    key.id = i.toString();
    //key.style.backgroundColor = "#20272d";
    key.style.border = "1px solid #414e58";

    if (hand === "r" && i === 22) { // place 'double-width-key'
      if (layout === "portrait") {
        key.style.gridColumn = "3 / span 2";
      } else if (layout === "landscape") {
        key.style.gridColumn = "5 / span 2";
      } else if (mobile === false) { // landscapeLong layout for mobile has no 'double-width-key' (extra key for fullscreen)
        key.style.gridColumn = "7 / span 2";
      }
    } else if (hand === "l" && i === 20 && layout === "portrait") {
      key.style.gridColumn = "1 / span 2";
    } else if (hand === "l" && i === 18 && layout === "landscape") {
      key.style.gridColumn = "1 / span 2";
    } else if (hand === "l" && i === 16 && layout === "landscapeLong" && mobile === false) {
      key.style.gridColumn = "1 / span 2";
    } else if (hand === "l" && i > 20 && layout === "portrait") { // place keys after 'double-width-key' (if exists before last key)
      key.style.gridColumn = `${(i % 4) + 2} / span 1`;
    } else if (hand === "l" && i > 18 && layout === "landscape") {
      key.style.gridColumn = `${(i % 6) + 2} / span 1`;
    } else if (hand === "l" && i > 16 && layout === "landscapeLong" && mobile === false) {
      key.style.gridColumn = `${(i % 8) + 2} / span 1`;
    } else { // place keys before 'double-width-key' (if exists)
      if (layout === "portrait") {
        key.style.gridColumn = `${(i % 4) + 1} / span 1`;
      } else if (layout === "landscape") {
        key.style.gridColumn = `${(i % 6) + 1} / span 1`;
      } else {
        key.style.gridColumn = `${(i % 8) + 1} / span 1`;
      }
    }

    let clickAtt = document.createAttribute("onclick");
    clickAtt.value = "keyClick(this.id)";
    key.setAttributeNode(clickAtt);

    key.style.lineHeight = `${keyHeight}px`;
    keyboard.appendChild(key);

    const keyPara = document.createElement('p');  // add <p> to key
    keyPara.classList.add('keyPara');
    keyPara.id = `keyPara${i}`;
    key.appendChild(keyPara);
  }
}

function destroyKeys() {
  let elements = document.getElementsByClassName('key');
  while(elements.length > 0){
      elements[0].parentNode.removeChild(elements[0]);
  }
}

function stylePage() {
  if (layout === "portrait") {
    fontSizeA = calcW / 10;
    fontSizeB = calcW / 23;
  } else if (layout === "landscape") {
    fontSizeA = calcH / 7.8;
    fontSizeB = calcH / 18;
  } else {
    fontSizeA = calcH / 6;
    fontSizeB = calcH / 16;
  }

  displayB.style.height= `${displayBheight}px`;
  displayA.style.height= `${displayAheight}px`;
  keyboard.style.height= `${keyboardHeight}px`;

  displayB.style.lineHeight = `${displayBheight}px`;
  displayBtext.style.display = "inline-block";
  displayBtext.style.verticalAlign = "middle";
  displayBtext.style.lineHeight = "normal";

  displayA.style.lineHeight = `${displayAheight}px`;
  displayAtext.style.display = "inline-block";
  displayAtext.style.verticalAlign = "middle";
  displayAtext.style.lineHeight = "normal";

  displayAtext.style.fontSize = `${fontSizeA}px`;
  displayBtext.style.fontSize = `${fontSizeB}px`;

  container.style.backgroundColor = "#101519";
  displayB.style.backgroundColor = "#192938";
  //body.style.background = "radial-gradient(#242d33, #101519)";
  body.style.background = "#7a7b6e";

  container.style.webkitBoxShadow = "2px 2px 17px 2px rgba(0, 0, 0, 0.4)";
  container.style.mozBoxShadow =  "2px 2px 17px 2px rgba(0, 0, 0, 0.4)";
  container.style.boxShadow = "2px 2px 17px 2px rgba(0, 0, 0, 0.4)";

  // ------------- keys styling ----------------------

  keysTemplate = setKeysTemplate();

  fontSizeKeys = keyHeight / 1.8;

  for (let i = 0; i < numOfKeys; i++) { // style each <p> on each key, including a string
    let thisKey = document.getElementById(`${i}`);
    let keyPara = document.getElementById(`keyPara${i}`);

    if (keysTemplate[i] === '^') { // special position for 'x^y' text (with supersript)
      vertOffset = fontSizeKeys * -0.198;
      horOffset = fontSizeKeys * -0.3;
      keyPara.innerHTML = `x<sup>y</sup>`;
      keyPara.style.margin = `${vertOffset}px ${horOffset}px 0 0`;
    } else if (keysTemplate[i] === 'S') { /// doesn't do anything (different) at the moment
      keyPara.innerHTML = keysTemplate[i];
    } else {
      keyPara.innerHTML = keysTemplate[i];
    }

    if (theme === "A") {
      thisKey.style.backgroundColor = "#14202b";
      thisKey.style.border = "none";
    } else {
      thisKey.style.backgroundColor = "#20272d";
      thisKey.style.border = "1px solid #414e58";
    }

    keyPara.style.textAlign = "center";

    if (keysTemplate[i] === '^') { // font sizes
      keyPara.style.fontSize = `${fontSizeKeys * 0.9}px`;
    } else {
      keyPara.style.fontSize = `${fontSizeKeys}px`;
    }

    switch (keysTemplate[i]) {
      case 'C':
        keyPara.style.color = "hsl(340, 64%, 55%)";
        let tooltipAttClr = document.createAttribute("title");
        tooltipAttClr.value = "clear all"; // Set the value of the html 'title' property (tooltip) attribute
        keyPara.setAttributeNode(tooltipAttClr);
        break;
      case '<':
        keyPara.style.color = "hsl(15, 60%, 63%)";
        let tooltipAttBsp = document.createAttribute("title");
        tooltipAttBsp.value = "backspace"; // Set the value of the html 'title' property (tooltip) attribute
        keyPara.setAttributeNode(tooltipAttBsp);
        break;
      case '=':
        keyPara.style.color = "hsl(124, 39%, 62%)";
        break;
      case '+': case '-': case '*': case '/':
        keyPara.style.color = "hsl(208, 96%, 56%)";
        break;
      case '±': case '^': case '(': case ')':
        keyPara.style.color = "hsl(208, 41%, 42%)";
        break;
      case 'S':
        keyPara.style.color = "hsl(273, 50%, 56%)";
        let tooltipAttSet = document.createAttribute("title");
        tooltipAttSet.value = "settings"; // Set the value of the html 'title' property (tooltip) attribute
        keyPara.setAttributeNode(tooltipAttSet);
        break;
      case 'F':
        keyPara.style.color = "hsl(297, 36%, 53%)";
        break;
      default:
        keyPara.style.color = "hsl(208, 52%, 72%)";
    }
  }
}

// ---------- event listeners and input/output logic ---------------------

function addEventListeners() {
  keys = document.querySelectorAll('.key');
  keys.forEach(key => key.addEventListener('mouseover', hover));
  keys = document.querySelectorAll('.key');
  keys.forEach(key => key.addEventListener('mouseout', unHover));
}

function hover() {
  if (mobile === false) {
    let thisID = this.id.toString();
    let element = document.getElementById(`keyPara${thisID}`);
    let style = window.getComputedStyle(element,"");
    let textColor = style.getPropertyValue("color");
    let hsl = getHSLvalues(textColor);
    prevColor = textColor;
    document.getElementById(`keyPara${thisID}`).style.color = `hsl(${hsl[0]}, ${hsl[1]}%, ${hsl[2] * 1.4}%)`;
  }
}

function unHover () {
  if (mobile === false) {
    let thisID = this.id.toString();
    document.getElementById(`keyPara${thisID}`).style.color = prevColor;
  }
}

function keyClick (clickedID) {
  function clickAnim() {
    let elem = document.getElementById(`${clickedID}`);

    switch (counter) { // NEED TO STORE BACKGROUND COLOUR AS VARIABLE!
        case 0: elem.style.background = `radial-gradient(${prevColor} 0%, #14202b 10%, #14202b 90%)`; break;
        case 1: elem.style.background = `radial-gradient(${prevColor} 0%, #14202b 20%, #14202b 90%)`; break;
        case 2: elem.style.background = `radial-gradient(${prevColor} 0%, #14202b 30%, #14202b 100%)`; break;
        case 3: elem.style.background = `radial-gradient(${prevColor} 0%, #14202b 40%, #14202b 100%)`; break;
        case 4: elem.style.background = `radial-gradient(${prevColor} 0%, #14202b 65%, #14202b 100%)`; break;
        case 5: elem.style.background = `radial-gradient(${prevColor} 0%, #14202b 40%, #14202b 100%)`; break;
        case 6: elem.style.background = `radial-gradient(${prevColor} 0%, #14202b 30%, #14202b 100%)`; break;
        case 7: elem.style.background = `radial-gradient(${prevColor} 0%, #14202b 20%, #14202b 100%)`; break;
        case 8: elem.style.background = `radial-gradient(${prevColor} 0%, #14202b 10%, #14202b 100%)`; break;
        case 9: elem.style.background = "#14202b"; counter = 0; clearInterval(myVar);
    }
    counter++;
  }

  if (mobile === true) {
    prevColor = document.getElementById(`keyPara${clickedID}`).style.getPropertyValue("color");
  }

  let counter = 0;
  let template = setKeysTemplate();

  input = template[clickedID]; // template[clickedID] is the character represented on the clicked calculator keypad key

  if (resultToClear === true) {
    if (input != "±" && input != "=") {
      if (input === "+" || input === "-" || input === "*"
        || input === "/" || input === "^" || input === "<" || input === ')' || input === '=') {
          if (infinityToClear === false) {
            history = "";
            updateDispB();
          }
      } else {
        history = "";
        updateDispB();
        strA = "";
        updateDispA("");
        infinityToClear = false;
      }
      if (infinityToClear === false) {
        resultToClear = false;
        digits = 0;
      }
    }
  }

  if (input === "S") {
    // trigger menu
  } else if (input === "F") {
    // trigger full-screen
  } else if (input === "C" || (infinityToClear === true && input === '<')) {
    clear();
  } else if (input === "<") {
    if (strA != "") {
      updateDispA(input);
    } else {
      updateDispB();
    }
  } else if (input === "+" || input === "-" || input === "*"
    || input === "/" || input === "^") {
      if (strA != "" && resultToClear === false) { // cannot be first action after clear all
            history = history + strA + input;
            updateDispA(input);
            updateDispB();
      } else if (operatorEdit === true) {
        updateDispB();
      }
  } else if (input === ".") {
      if (decimal === false) { // cannot add 2nd decimal point to display A
        if (strA === "") { // add 0 prefix if 1st input after dispA clear
          input = "0.";
          digits++;
          decimal = true;
          updateDispA(input);
        } else {
          decimal = true;
          updateDispA(input);
        }
      }
  } else if (input === "(") {
      updateDispA(input);
  } else if (input === ")") {
      if (parenth > 0) { // cannot close unopened parentheses
        updateDispA(input);
      }
  } else if (input === "±") {
    updateDispA(input);
  } else if (input === "=") {
    if (history != "" && resultToClear === false) { // cannot be first action after clear all
      if (parenth === 0 && operatorEdit === false)
      evaluate();
    }
  } else { // digit (0 - 9 or .)
    if (digits < 15) {
      digits++;
      updateDispA(input);
    }
  }

  let myVar = setInterval(function(){ clickAnim() }, 20);
}

function round(number, precision) {
  var shift = function (number, precision, reverseShift) {
    if (reverseShift) {
      precision = -precision;
    }
    var numArray = ("" + number).split("e");
    return +(numArray[0] + "e" + (numArray[1] ? (+numArray[1] + precision) : precision));
  };

  return shift(Math.round(shift(number, precision, false)), precision, true);
}

function parseResult(string) {
  function moveDecimal(numStr) {
    let index = numStr.indexOf('.');
    let newStr = "";

    if ((negative === true && index != 2) || (negative === false && index != 1)) {
      let part1 = numStr.slice(0, index);
      let part2 = numStr.slice(index + 1, numStr.length);
      if (negative === false) {
        newStr = numStr.slice(0, 1) + '.' + part1.slice(1, part1.length) + part2;
        return [newStr, index - 1];
      } else {
        newStr = numStr.slice(0, 2) + '.' + part1.slice(2, part1.length) + part2;
        return [newStr, index - 2];
      }
    } else {
      return [numStr, 0];
    }
  }

  function insertDecimal(numStr) {
    let newStr = "";
    let index = 0;

    if (negative === true) {
      index = 2;
    } else {
      index = 1;
    }

    let part1 = numStr.slice(0, index);
    let part2 = numStr.slice(index, numStr.length);
    newStr = part1 + '.' + part2;
    return [newStr, numStr.length -index];
  }

  function positionDecimal(numStr) {
    if (numStr.indexOf('.') < 0) { // does not have decimal
      decArry = insertDecimal(numStr);
    } else { // has decimal
      decArry = moveDecimal(numStr);
    }

    return decArry;
  }

  function roundToFit(numStr) {
    if (negative === false) {
      result = round(parseFloat(numStr), lenLimit - expStr.length - 2);
    } else {
      result = round(parseFloat(numStr), lenLimit - expStr.length - 3);
    }

    return result;
  }

  function makeExp(exp) {
    if (exp >= 0) {
      expStr = "e+" + exp.toString();
    } else {
      expStr = "e" + exp.toString();
    }

    return expStr;
  }

  function parseExponent(numStr) {
    expStr = numStr.slice(numStr.indexOf('e'), numStr.length);
    numStr = numStr.slice(0, numStr.length - expStr.length);

    if (expStr.indexOf('-') > -1) {
      exp = parseInt(expStr.slice(expStr.indexOf('-'), expStr.length));
    } else {
      exp = parseInt(expStr.slice(expStr.indexOf('+') + 1, expStr.length));
    }

    return [numStr, exp];
  }

  let num = parseFloat(string);
  let lenLimit = 16;
  let negative = false;
  let result = 0;
  let exp = 0;
  let expStr = "";
  let decArry = [];

  if (string.slice(0, 1) === '-') {
    lenLimit = lenLimit + 1 // (including '-')
    negative = true;
  }

  if ((num >= 10000000000000000 || num <= -10000000000000000) && string.indexOf('e') < 0) { // value too large for display, no exponent, with or without decimals
    decArry = positionDecimal(string);
    string = decArry[0];
    expStr = makeExp(decArry[1]);
    result = roundToFit(string);
    return result.toString() + expStr;
  } else if (string.indexOf('e') > -1) { // has exponent
    let parseExp = parseExponent(string);
    string = parseExp[0];
    decArry = positionDecimal(string);
    string = decArry[0];
    exp = parseExp[1] + decArry[1];
    expStr = makeExp(exp);
    result = roundToFit(string);
    return result.toString() + expStr;
  } else { // all other forms of result
    let index = string.indexOf('.');
    result = round(parseFloat(string), lenLimit - index - 1);
    return result.toString();
  }
}

function evaluate() {
  history = history + strA;
  let toEval = history.replace(/--/g,'+'); // JS eval() doesn't like '--'
  let result = eval(toEval);
  let resultStr = result.toString();

  if (resultStr.slice(0, 1) === 'I' || resultStr.slice(0, 2) === '-I' || resultStr.slice(0, 1) === 'N') {
    infinityToClear = true;
    resultToClear = true;
    if (resultStr === "NaN"){
      resultStr = "undefined: 0/0";
    } else if (resultStr.slice(0, 2) != '-I') {
      resultStr = "infinity";
    } else {
      resultStr = "-infinity";
    }
  } else {
    resultStr = parseResult(resultStr);
  }

  history = history + "=";
  updateDispB();
  strA = resultStr;
  updateDispA("");

  if (result < 0) {
    positive = false;
  } else {
    positive = true;
  }
  if (resultStr.indexOf('.') > -1) {
    decimal = true;
  } else {
    decimal = false;
  }

  resultToClear = true;
}

function updateDispA(input) {
  if (operatorEdit === false) {
    if (input === "±") {
      if (infinityToClear === false) {
        if (positive === true) {
          strA = "-" + strA;
          positive = false;
        } else {
          strA = strA.slice(1, strA.length);
          positive = true;
        }
      }
    } else if (input === "(") {
        if (strA === "") {
          parenth = parenth + 1;
          history = history + "(";
          updateDispB();
        }
    } else if (input === ")") {
      if (strA === "") {
        let check = history.slice(history.length-1, history.length);
        if (check != "+" && check != "-" && check != "*"
            && check != "/" && check != "^" && check != '(') {
          history = history + ")";
          parenth = parenth - 1;
          updateDispB();
        }
      } else if (digits < 15) {
          parenth = parenth - 1;
          strA = strA + ")";
      }
    } else if (input === "<") {
        if (strA != "") {
          let check = strA.slice(strA.length-1, strA.length);
          if ((history.length === 0 && strA.length === 1) || strA.indexOf('e') > -1) {
            clear();
          } else if (check === ".") {
            decimal = false;
          }
          if (check === ')') {
            parenth = parenth + 1;
          }
          strA = strA.slice(0, -1);
          digits = digits - 1;
        }
    } else if (input === "+" || input === "-" || input === "*"
      || input === "/" || input === "^") {
        strA = "";
        digits = 0;
        decimal = false;
        positive = true;
    } else {
      strA = strA + input;
    }
  }

  displayAtext.innerHTML = strA + "&nbsp;";
}

function updateDispB() {
  if (input === '<') {
    check = history.slice(history.length-1, history.length);
    if ((check === '+' || check === '-' || check === '/' || check === '*' ||
    check === '^') && operatorEdit === false) {
      history = history.slice(0, history.length - 1);
      operatorEdit = true;
    } else if (strA === "") {
      clear();
    }
  } else if ((input === '+' || input === '-' || input === '/' || input === '*' ||
    input === '^') && operatorEdit === true) {
      history = history + input;
      operatorEdit = false;
  }

  let output = "";

  switch (layout) {
    case "portrait":
      if (history.length > (maxCharsPortrait - 2)) {
        output = "..." + history.slice(history.length - maxCharsPortrait + 5, history.length);
      } else {
        output = history;
      }
      break;
    case "landscape":
      if (history.length > (maxCharsLandscape - 2)) {
        output = "..." + history.slice(history.length - maxCharsLandscape + 5, history.length);
      } else {
        output = history;
      }
      break;
    case "landscapeLong":
      if (history.length > (maxCharsLandsLong - 2)) {
        output = "..." + history.slice(history.length - maxCharsLandsLong + 5, history.length);
      } else {
        output = history;
      }
      break;
  }

  output = output + "&nbsp;&nbsp;";
  displayBtext.innerHTML = output;
}

function clear() {
  strA = "";
  strB = "";
  history = "";
  decimal = false;
  parenth = 0;
  digits = 0;
  positive = true;
  displayAtext.innerHTML = "";
  displayBtext.innerHTML = "waiting for input...&nbsp;&nbsp;";
  infinityToClear = false;
  operatorEdit = false;
}

/** Converts an RGB color value to HSL. Conversion formula adapted from
 *  http://en.wikipedia.org/wiki/HSL_color_space. Assumes r, g, and b are
 *  contained in the set [0, 255] and returns h, s, and l in the set [0, 1].
 *  adapted from: https://gist.github.com/mjackson/5311256 **/
function rgbToHsl(r, g, b) {
  r /= 255, g /= 255, b /= 255;
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;

  if (max == min) {
    h = s = 0; // achromatic
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  h = Math.floor(360 - (h * 360)); // hue scale used here was inversion of that used by browsers
  s = Math.floor(s * 100);
  l = Math.floor(l * 100);
  return [ h, s, l ];
}

function parseRGB(rgbString) {
    let red = "";
    let green = "";
    let blue = "";
    let char = "";
    let color = "";
    let rgbArray = [];

    for (let i = 1; i < 4; i++) { // this code block strips rgb values out of css rgb string (background-color of a 'square' element)
      if (i == 1) {
        rgbString = rgbString.slice(4);
      } else {
        rgbString = rgbString.slice(2);
      }
      char = rgbString.slice(0, 1);
      color = "";
      do {
        color = color + char;
        rgbString = rgbString.slice(1);
        char = rgbString.slice(0, 1);
      } while (char != "," && char != ")");
      if (i == 1) {red = color;}
      else if (i == 2) {blue = color;}
      else {green = color;}
    }

    rgbArray[0] = parseInt(red);
    rgbArray[1] = parseInt(green);
    rgbArray[2] = parseInt(blue);
    return rgbArray;
  }

  function getHSLvalues(rgbString) {
    let rgbArray = parseRGB(rgbString);
    let hslArray = rgbToHsl(rgbArray[0], rgbArray[1], rgbArray[2])
    return hslArray;
  }

// ---------- initial declarations and commands -------------

let calcW = 0;
let WinOutW = 0;
let screenW = 0;
let calcH = 0;
let WinOutH = 0;
let screenH = 0;
let winRatio = 0;
let mobile = false;
let layout = "portrait"; // 3 options: portrait, landscape, landscapeLong
let hand = "r";
let theme = "A"; // A or B

let displayAheight = 0;
let displayBheight = 0;
let keyboardHeight = 0;
let keyHeight = 0;
let keyRows = 0;
let keys = [];

let fontSizeA = 0;
let fontSizeB = 0;
let fontSizeKeys = 0;

let gridRowHeight = 0;
let gridColumns = 0;
let numOfKeys = 0;
let keysTemplate = [];

let horOffset = 0;
let vertOffset = 0;

// maximum string lengths for secondary display (displayB):
let maxCharsPortrait = 39;
let maxCharsLandscape = 41;
let maxCharsLandsLong = 66;

let strA = "";
let strB = "";
let history = "";
let input = "";

let parenth = 0;
let decimal = false;
let digits = 0;
let positive = true;
let resultToClear = false
let infinityToClear = false;
let operatorEdit = false;

let prevColor = "";

let body = document.getElementsByTagName('body')[0];
let para = document.getElementsByTagName('p')[0];
let displayA = document.getElementById('displayA');
let displayB = document.getElementById('displayB');
let displayAtext = document.getElementById('displayAtext');
let displayBtext = document.getElementById('displayBtext');
let keyboard = document.getElementById('keyboard');
let container = document.getElementById('container');

body.style.color = "#c0daf1";
body.style.fontFamily = "'Ubuntu Mono', monospace";
body.style.fontWeight = "normal";
container.style.margin = "auto";
displayB.style.textAlign = "right";
displayA.style.backgroundColor = "black";
displayA.style.textAlign = "right";
keyboard.style.backgroundColor = "#11443f";
keyboard.style.display = "grid";
keyboard.style.margin = "auto";

drawPage(); // Also called whenever window (body) is resized
clear();

</script>

</body>
</html>
