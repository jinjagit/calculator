<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="./css/reset.css" media="screen" />
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700" rel="stylesheet">
  <link rel="stylesheet" href="./css/style.css" media="screen" />
  <title >Calculator:</title>
</head>
<body onresize="drawPage()">
  <div id="container">
    <div id="displayB">
      <span id="displayBtext">39_characters__________________________</span>
    </div>
    <div id="displayA">
      <span id="displayAtext">3.141592653589793&nbsp;</span>
    </div>
    <div id="keyboard">
    </div>
  </div>

<script>
// Calculator - by Simon Tharby, 2018 (solution to; https://www.theodinproject.com/courses/web-development-101/lessons/calculator)
// Mobile focussed design that is also appropriately responsive to desktop environment.
// Disambiguation: In this code, 'key' refers / relates to a / the key(s) on the rendered calculator

function updateText() {
  let summary = `mode: ${layout} (${hand}) mobile: ${mobile}`;
  while (summary.length < 39) {
    summary = summary + "_";
  }
  displayBtext.innerHTML = summary;
}

// --------------------- layout and basic styling -----------------------------

function setKeysTemplate() {
  // '^' = exponentiation, 'C' = clear, '<' = backspace,
  // 'S' = settings, 'F' = fullscreen (landscapeLong && mobile, only)
  let template = [];
  if (layout === "portrait") {
    if (hand === "r") {
      template = ['±', 'S', '<', 'C',
                  '(', ')', '^', '/',
                  '7', '8', '9', '*',
                  '4', '5', '6', '-',
                  '1', '2', '3', '+',
                  '.', '0', '='];
    } else {
      template = ['C', '<', 'S', '±',
                  '/', '^', '(', ')',
                  '*', '7', '8', '9',
                  '-', '4', '5', '6',
                  '+', '1', '2', '3',
                  '=', '0', '.'];
    }
  } else if (layout === "landscape") {
    if (hand === "r") {
      template = ['7', '8', '9', '/', '^', 'C',
                  '4', '5', '6', '*', '(', '<',
                  '1', '2', '3', '-', ')', 'S',
                  '±', '0', '.', '+', '='];
    } else {
      template = ['C', '^', '/', '7', '8', '9',
                  '<', '(', '*', '4', '5', '6',
                  'S', ')', '-', '1', '2', '3',
                  '=', '+', '.', '0', '±'];
    }
  } else if (layout === "landscapeLong" && mobile === false) {
    if (hand === "r") {
      template = ['±', '7', '8', '9', '^', 'S', '<', 'C',
                  '.', '4', '5', '6', '+', '*', '(', ')',
                  '0', '1', '2', '3', '-', '/', '='];
    } else {
      template = ['C', '<', 'S', '^', '±', '7', '8', '9',
                  '(', ')', '*', '+', '.', '4', '5', '6',
                  '=', '/', '-', '0', '1', '2', '3'];
    }
  } else { // landscapeLong && mobile: true
    if (hand === "r") {
      template = ['±', '7', '8', '9', 'F', 'S', '<', 'C',
                  '.', '4', '5', '6', '+', '*', '(', ')',
                  '0', '1', '2', '3', '-', '/', '^', '='];
    } else {
      template = ['C', '<', 'F', 'S', '±', '7', '8', '9',
                  '(', ')', '*', '+', '.', '4', '5', '6',
                  '=', '^', '/', '-', '0', '1', '2', '3'];
    }
  }
  return template;
}

function getDisplayData() {
  calcW = window.innerWidth;
  WinOutW = window.outerWidth;
  screenW = screen.width;
  calcH = window.innerHeight;
  WinOutH = window.outerHeight;
  screenH = screen.height;
  if (screen.width < window.innerWidth) {
    mobile = true; // probably mobile, but not certain
  } else {mobile = false;}
}

function setLayout() {
  if (mobile === false && screenW < 2200) {
    if (calcW > 480) { calcW = 480; }
    if (calcH > 385) { calcH = 385; }
  }
  winRatio = calcW / calcH;
  if (winRatio < 1.2) {
    layout = "portrait";
    displayBheight = calcH * (1 / 15);
    displayAheight = calcH * (2 / 15);
    keyRows = 6;
  } else if (winRatio >= 1.2 && winRatio < 2.1) {
    layout = "landscape";
    displayBheight = calcH * (1 / 11);
    displayAheight = calcH * (2 / 11);
    keyRows = 4;
  }
  else {
    layout = "landscapeLong";
    displayBheight = calcH * (1 / 9);
    displayAheight = calcH * (2 / 9);
    keyRows = 3;
  }
  keyboardHeight = calcH - displayAheight - displayBheight;
  if (layout === "landscapeLong" && mobile === true) {
    numOfKeys = 24;
  } else {
    numOfKeys = 23;
  }
  keyHeight = (keyboardHeight / keyRows); // -2px for key 1px border (this could change, depending on Theme)
}

function drawPage() {
  getDisplayData();
  setLayout();
  destroyKeys();
  container.style.width = `${calcW}px`
  if (mobile === false) {
    container.style.margin = `${(window.innerHeight - calcH) / 2}px auto`;
  } else {
    container.style.margin = `auto`;
  }
  updateText();
  createKeys();
  stylePage();
  addEventListeners();
}

function createKeys() {
  for (let i = 0; i < numOfKeys; i++) {
    const key = document.createElement('div');
    key.classList.add('key');
    key.id = i.toString();
    //key.style.backgroundColor = "#20272d";
    key.style.border = "1px solid #414e58";
    if (hand === "r" && i === 22) { // place 'double-width-key'
      if (layout === "portrait") {
        key.style.gridColumn = "3 / span 2";
      } else if (layout === "landscape") {
        key.style.gridColumn = "5 / span 2";
      } else if (mobile === false) { // landscapeLong layout for mobile has no 'double-width-key' (extra key for fullscreen)
        key.style.gridColumn = "7 / span 2";
      }
    } else if (hand === "l" && i === 20 && layout === "portrait") {
      key.style.gridColumn = "1 / span 2";
    } else if (hand === "l" && i === 18 && layout === "landscape") {
      key.style.gridColumn = "1 / span 2";
    } else if (hand === "l" && i === 16 && layout === "landscapeLong" && mobile === false) {
      key.style.gridColumn = "1 / span 2";
    } else if (hand === "l" && i > 20 && layout === "portrait") { // place keys after 'double-width-key' (if exists before last key)
      key.style.gridColumn = `${(i % 4) + 2} / span 1`;
    } else if (hand === "l" && i > 18 && layout === "landscape") {
      key.style.gridColumn = `${(i % 6) + 2} / span 1`;
    } else if (hand === "l" && i > 16 && layout === "landscapeLong" && mobile === false) {
      key.style.gridColumn = `${(i % 8) + 2} / span 1`;
    } else { // place keys before 'double-width-key' (if exists)
      if (layout === "portrait") {
        key.style.gridColumn = `${(i % 4) + 1} / span 1`;
      } else if (layout === "landscape") {
        key.style.gridColumn = `${(i % 6) + 1} / span 1`;
      } else {
        key.style.gridColumn = `${(i % 8) + 1} / span 1`;
      }
    }
    key.style.lineHeight = `${keyHeight}px`;
    keyboard.appendChild(key);

    const keyPara = document.createElement('p');  // add <p> to key
    keyPara.classList.add('keyPara');
    keyPara.id = `keyPara${i}`;
    key.appendChild(keyPara);
  }
}

function destroyKeys() {
  let elements = document.getElementsByClassName('key');
  while(elements.length > 0){
      elements[0].parentNode.removeChild(elements[0]);
  }
}

function stylePage() {
  if (layout === "portrait") {
    fontSizeA = calcW / 10;
    fontSizeB = calcW / 23;
  } else if (layout === "landscape") {
    fontSizeA = calcH / 7.8;
    fontSizeB = calcH / 18;
  } else {
    fontSizeA = calcH / 6;
    fontSizeB = calcH / 16;
  }

  displayB.style.height= `${displayBheight}px`;
  displayA.style.height= `${displayAheight}px`;
  keyboard.style.height= `${keyboardHeight}px`;

  displayB.style.lineHeight = `${displayBheight}px`;
  displayBtext.style.display = "inline-block";
  displayBtext.style.verticalAlign = "middle";
  displayBtext.style.lineHeight = "normal";

  displayA.style.lineHeight = `${displayAheight}px`;
  displayAtext.style.display = "inline-block";
  displayAtext.style.verticalAlign = "middle";
  displayAtext.style.lineHeight = "normal";

  displayAtext.style.fontSize = `${fontSizeA}px`;
  displayBtext.style.fontSize = `${fontSizeB}px`;

  container.style.backgroundColor = "#101519";
  displayB.style.backgroundColor = "#192938";
  body.style.background = "radial-gradient(#242d33, #101519)";

  container.style.webkitBoxShadow = "2px 2px 17px 2px rgba(0, 0, 0, 0.4)";
  container.style.mozBoxShadow =  "2px 2px 17px 2px rgba(0, 0, 0, 0.4)";
  container.style.boxShadow = "2px 2px 17px 2px rgba(0, 0, 0, 0.4)";

  // ------------- keys styling ----------------------

  keysTemplate = setKeysTemplate();

  fontSizeKeys = keyHeight / 1.8;

  for (let i = 0; i < numOfKeys; i++) { // style each <p> on each key, including a string
    let thisKey = document.getElementById(`${i}`);
    let keyPara = document.getElementById(`keyPara${i}`);
    if (keysTemplate[i] === '^') { // special position for 'x^y' text (with supersript)
      vertOffset = fontSizeKeys * -0.198;
      horOffset = fontSizeKeys * -0.3;
      keyPara.innerHTML = `x<sup>y</sup>`;
      keyPara.style.margin = `${vertOffset}px ${horOffset}px 0 0`;
    } else if (keysTemplate[i] === 'S') { /// doesn't do anything (different) at the moment
      keyPara.innerHTML = keysTemplate[i];
    } else {
      keyPara.innerHTML = keysTemplate[i];
    }

    if (theme === "A") {
      thisKey.style.backgroundColor = "#101519";
      thisKey.style.border = "none";
    } else {
      thisKey.style.backgroundColor = "#20272d";
      thisKey.style.border = "1px solid #414e58";
    }

    keyPara.style.textAlign = "center";

    if (keysTemplate[i] === '^') { // font sizes
      keyPara.style.fontSize = `${fontSizeKeys * 0.9}px`;
    } else {
      keyPara.style.fontSize = `${fontSizeKeys}px`;
    }

    if (keysTemplate[i] === 'C') { // colors (text) + tooltips
      keyPara.style.color = "hsl(340, 64%, 55%)";
      let tooltipAttClr = document.createAttribute("title");
      tooltipAttClr.value = "clear all"; // Set the value of the 'title' (tooltip) attribute
      keyPara.setAttributeNode(tooltipAttClr);
    } else if (keysTemplate[i] === '<') {
      keyPara.style.color = "hsl(15, 60%, 63%)";
      let tooltipAttBsp = document.createAttribute("title");
      tooltipAttBsp.value = "backspace"; // Set the value of the 'title' (tooltip) attribute
      keyPara.setAttributeNode(tooltipAttBsp);
    } else if (keysTemplate[i] === '=') {
      keyPara.style.color = "hsl(124, 39%, 62%)";
    } else if (keysTemplate[i] === '+' || keysTemplate[i] === '-' ||
              keysTemplate[i] === '*' || keysTemplate[i] === '/') {
      keyPara.style.color = "hsl(208, 96%, 56%)";
    } else if (keysTemplate[i] === '±' || keysTemplate[i] === '^' ||
              keysTemplate[i] === '(' || keysTemplate[i] === ')') {
      keyPara.style.color = "hsl(208, 41%, 42%)";
    } else if (keysTemplate[i] === 'S') {
      keyPara.style.color = "hsl(273, 50%, 56%)";
      let tooltipAttSet = document.createAttribute("title");
      tooltipAttSet.value = "settings"; // Set the value of the 'title' (tooltip) attribute
      keyPara.setAttributeNode(tooltipAttSet);
    } else if (keysTemplate[i] === 'F') {
      keyPara.style.color = "hsl(297, 36%, 53%)";
    } else {
      keyPara.style.color = "hsl(208, 52%, 72%)";
    }

  }
}

// ---------- event listeners and related actions ---------------------------

function addEventListeners() {
  keys = document.querySelectorAll('.key');
  keys.forEach(key => key.addEventListener('mouseover', hover));

  keys = document.querySelectorAll('.key');
  keys.forEach(key => key.addEventListener('mouseout', unHover));
}

function hover() {
  let thisID = this.id.toString();
  let element = document.getElementById(`keyPara${thisID}`);
  let style = window.getComputedStyle(element,"");
  let textColor = style.getPropertyValue("color");
  let hsl = getHSLvalues(textColor);

  prevColor = textColor;
  console.log("text color: " + textColor);
  console.log(hsl);
  // get element child paragraph (text) color and store
  // set element child paragraph (text) color to brighter color
  document.getElementById(`keyPara${thisID}`).style.color = `hsl(${hsl[0]}, ${hsl[1]}%, ${hsl[2]}%)`;
  console.log(hsl[2] * 1.25);
}

function unHover () {
  let thisID = this.id.toString();
  // reset element child paragraph (text) color to pre-hover value.
  document.getElementById(`keyPara${thisID}`).style.color = prevColor;
}

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * adapted from: https://gist.github.com/mjackson/5311256
 */
function rgbToHsl(r, g, b) {
  r /= 255, g /= 255, b /= 255;
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;

  if (max == min) {
    h = s = 0; // achromatic
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  h = Math.floor(h * 384);
  s = Math.floor(s * 100);
  l = Math.floor(l * 100);
  return [ h, s, l ];
}

function parseRGB(rgbString) {
    let red = "";
    let green = "";
    let blue = "";
    let char = "";
    let color = "";
    let rgbArray = [];

    for (let i = 1; i < 4; i++) { // this code block strips rgb values out of css rgb string (background-color of a 'square' element)
      if (i == 1) {
        rgbString = rgbString.slice(4);
      } else {
        rgbString = rgbString.slice(2);
      }
      char = rgbString.slice(0, 1);
      color = "";
      do {
        color = color + char;
        rgbString = rgbString.slice(1);
        char = rgbString.slice(0, 1);
      } while (char != "," && char != ")");
      if (i == 1) {red = color;}
      else if (i == 2) {blue = color;}
      else {green = color;}
    }

    rgbArray[0] = parseInt(red);
    rgbArray[1] = parseInt(green);
    rgbArray[2] = parseInt(blue);
    return rgbArray;
  }

  function getHSLvalues(rgbString) {
    let rgbArray = parseRGB(rgbString);
    let hslArray = rgbToHsl(rgbArray[0], rgbArray[1], rgbArray[2])
    return hslArray;
  }

// ---------- initial declarations and commands -------------

let calcW = 0;
let WinOutW = 0;
let screenW = 0;
let calcH = 0;
let WinOutH = 0;
let screenH = 0;
let winRatio = 0;
let mobile = false;
let layout = "portrait"; // 3 options: portrait, landscape, landscapeLong
let hand = "r";
let theme = "A"; // A or B

let displayAheight = 0;
let displayBheight = 0;
let keyboardHeight = 0;
let keyHeight = 0;
let keyRows = 0;
let keys = [];

let fontSizeA = 0;
let fontSizeB = 0;
let fontSizeKeys = 0;

let gridRowHeight = 0;
let gridColumns = 0;
let numOfKeys = 0;
let keysTemplate = [];

let horOffset = 0;
let vertOffset = 0;

let prevColor = "";

let body = document.getElementsByTagName('body')[0];
let para = document.getElementsByTagName('p')[0];
let displayA = document.getElementById('displayA');
let displayB = document.getElementById('displayB');
let displayAtext = document.getElementById('displayAtext');
let keyboard = document.getElementById('keyboard');
let container = document.getElementById('container');

body.style.color = "#c0daf1";
body.style.fontFamily = "'Ubuntu Mono', monospace";
body.style.fontWeight = "normal";
container.style.margin = "auto";
displayB.style.textAlign = "right";
displayA.style.backgroundColor = "black";
displayA.style.textAlign = "right";
keyboard.style.backgroundColor = "#11443f";
keyboard.style.display = "grid";
keyboard.style.margin = "auto";

drawPage(); // Also called whenever window (body) is resized

</script>

</body>
</html>
